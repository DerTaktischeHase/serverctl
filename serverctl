#!/usr/bin/env bash
set -euo pipefail

VERSION="1.0.4"

REPO_RAW_URL="https://raw.githubusercontent.com/DerTaktischeHase/serverctl/main"
SELF_PATH="$HOME/.local/bin/serverctl"

get_remote_version() {
  command -v curl >/dev/null 2>&1 || return 1
  curl -fsSL --max-time 2 "$REPO_RAW_URL/serverctl" 2>/dev/null \
    | sed -n 's/^VERSION="\([^"]*\)".*/\1/p' \
    | head -n 1
}

ver_to_num() {
  # "1.2.3" -> 001002003 (für Vergleich)
  local v="${1:-0.0.0}"
  IFS='.' read -r a b c <<< "$v"
  printf "%03d%03d%03d" "${a:-0}" "${b:-0}" "${c:-0}"
}

# -------------------------------
# Update
# -------------------------------
if [[ "${1:-}" == "--update" ]]; then
  command -v curl >/dev/null 2>&1 || { echo "Fehler: curl fehlt (installiere mit: sudo apt install curl)"; exit 1; }

  remote_ver="$(get_remote_version || true)"
  if [[ -z "${remote_ver:-}" ]]; then
    echo "Fehler: Konnte Remote-Version nicht abrufen."
    exit 1
  fi

  if [[ "$(ver_to_num "$remote_ver")" -le "$(ver_to_num "$VERSION")" ]]; then
    echo "Kein Update nötig. Lokal: $VERSION, Repo: $remote_ver"
    exit 0
  fi

  echo "Update verfügbar: Lokal $VERSION → Repo $remote_ver"
  read -rp "Jetzt aktualisieren? (y/N): " answer
  if [[ "$answer" != "y" && "$answer" != "Y" ]]; then
    echo "Abgebrochen."
    exit 0
  fi

  tmp="$(mktemp)"
  curl -fsSL "$REPO_RAW_URL/serverctl" -o "$tmp"
  chmod +x "$tmp"
  mv "$tmp" "$SELF_PATH"

  echo "✓ Aktualisiert: $SELF_PATH"
  echo "Starte jetzt neu: serverctl"
  exit 0
fi

# -------------------------------
# Version
# -------------------------------
if [[ "${1:-}" == "--version" ]]; then
  echo "serverctl version $VERSION"
  exit 0
fi

# -------------------------------
# Uninstall
# -------------------------------
if [[ "${1:-}" == "--uninstall" ]]; then
  echo "serverctl wird deinstalliert."
  read -rp "Fortfahren? (y/N): " answer

  if [[ "$answer" != "y" && "$answer" != "Y" ]]; then
    echo "Abgebrochen."
    exit 0
  fi

  BIN="$HOME/.local/bin/serverctl"
  BASHRC="$HOME/.bashrc"

  # Binary entfernen
  if [ -f "$BIN" ]; then
    rm -f "$BIN"
    echo "✓ Entfernt: $BIN"
  else
    echo "Hinweis: $BIN nicht gefunden"
  fi

  # SSH-Hinweis aus .bashrc entfernen
  if [ -f "$BASHRC" ] && grep -q "SERVERCTL_HINT_SHOWN" "$BASHRC"; then
    sed -i '/serverctl Hinweis bei SSH-Login/,+6d' "$BASHRC"
    echo "✓ SSH-Hinweis aus ~/.bashrc entfernt"
  fi

  echo
  echo "serverctl wurde erfolgreich deinstalliert."
  echo "Öffne eine neue Shell, um die Änderung zu übernehmen."

  exit 0
fi

# -------------------------------
# Help
# -------------------------------
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  cat << 'EOF'
serverctl – Server Wartungs- & Monitoring-Cockpit (SSH-freundlich)

Verwendung:
  serverctl              Zeigt die Server-Übersicht
  serverctl --help       Diese Hilfe anzeigen
  serverctl --version    Zeigt welche Version du nutzt
  serverctl --update     Aktualisiert serverctl aus dem GitHub-Repo
  serverctl --uninstall  Deinstalliert serverctl (entfernt auch SSH-Hinweis aus ~/.bashrc)

Bearbeiten:
  nano ~/.local/bin/serverctl

Hinweise:
  - --update lädt die Datei aus dem Repository und ersetzt ~/.local/bin/serverctl
  - Nach --uninstall ist serverctl entfernt und der Befehl nicht mehr verfügbar.
EOF
  exit 0
fi

# -------------------------------
# Update Hinweis (nur Hinweis, kein Auto-Update)
# -------------------------------
remote_ver="$(get_remote_version || true)"
if [[ -n "${remote_ver:-}" && "$(ver_to_num "$remote_ver")" -gt "$(ver_to_num "$VERSION")" ]]; then
  echo "Hinweis: Update verfügbar (lokal: $VERSION → repo: $remote_ver). Nutze: serverctl --update"
  echo
fi

# -------------------------------
# UI Helpers (Layout + Farben)
# -------------------------------
is_tty=false
if [[ -t 1 ]]; then is_tty=true; fi

c_reset=""
c_red=""
c_yellow=""
c_green=""
c_cyan=""
c_dim=""

if [[ "$is_tty" == true ]]; then
  c_reset=$'\033[0m'
  c_red=$'\033[31m'
  c_yellow=$'\033[33m'
  c_green=$'\033[32m'
  c_cyan=$'\033[36m'
  c_dim=$'\033[2m'
fi

section() {
  local title="$1"
  local line="--------------------------------------------------------------------------"
  # 42 passt gut zu deinem Beispiel; der Rest wird mit Strichen gefüllt
  printf "%s< %s >%s\n" "${line:0:33}" "$title" "${line:0:33}"
}

temp_badge() {
  local t="$1"  # numeric
  if [[ -z "${t:-}" ]]; then
    echo "UNKNOWN"
    return 0
  fi

  # Pi-typische Daumenregeln:
  # <60 OK, 60-75 WARN, >=75 HOT
  if awk "BEGIN{exit !($t < 60)}"; then
    echo "${c_green}OK${c_reset}"
  elif awk "BEGIN{exit !($t < 75)}"; then
    echo "${c_yellow}WARN${c_reset}"
  else
    echo "${c_red}HOT${c_reset}"
  fi
}

status_color() {
  local st="$1"
  case "$st" in
    UP) echo "${c_green}${st}${c_reset}" ;;
    DOWN) echo "${c_red}${st}${c_reset}" ;;
    UNKNOWN) echo "${c_yellow}${st}${c_reset}" ;;
    *) echo "$st" ;;
  esac
}

# -------------------------------
# Output
# -------------------------------
clear
echo "=================================================="
echo " serverctl  v${VERSION}   ($(hostname))"
echo "=================================================="
echo

section "System"
uname -a
uptime || true
echo

section "CPU Temperature"
# Wunschformat: CPU-TEMP=44.4'C + Warnstufe
temp_str=""
temp_num=""
if command -v vcgencmd >/dev/null 2>&1; then
  temp_str="$(vcgencmd measure_temp 2>/dev/null || true)"   # temp=44.4'C
  temp_num="$(echo "$temp_str" | sed -n "s/.*=\([0-9.]\+\).*/\1/p" | head -n 1)"
elif command -v sensors >/dev/null 2>&1; then
  # Versuch: erste gefundene "Package id 0" oder "CPU" oder erste Temperatur
  temp_num="$(sensors 2>/dev/null | sed -n 's/.*+\([0-9.]\+\)°C.*/\1/p' | head -n 1)"
fi

if [[ -n "${temp_num:-}" ]]; then
  badge="$(temp_badge "$temp_num")"
  printf "CPU-TEMP=%s'C  [%b]\n" "$temp_num" "$badge"
else
  echo "CPU-TEMP=UNKNOWN  (Tipp: Raspberry Pi: vcgencmd, sonst: sudo apt install lm-sensors && sudo sensors-detect)"
fi
echo

section "Memory"
if command -v free >/dev/null 2>&1; then
  free -h
else
  echo "free nicht verfügbar (Tipp: sudo apt install procps)"
fi
echo

section "Storage"
df -h -x tmpfs -x devtmpfs 2>/dev/null || df -h || true
echo

echo "Block-Devices:"
if command -v lsblk >/dev/null 2>&1; then
  lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINTS -e7 2>/dev/null || lsblk || true
else
  echo "lsblk nicht verfügbar (Tipp: sudo apt install util-linux)"
fi
echo

section "Network"
if command -v ip >/dev/null 2>&1; then
  # farbig markieren: Interface + Status + IPs
  ip -br a | awk -v cg="$c_green" -v cr="$c_red" -v cy="$c_yellow" -v cn="$c_reset" '
    {
      iface=$1; state=$2;
      $1=""; $2="";
      sub(/^ +/,""); rest=$0;
      color=cn;
      if (state=="UP") color=cg;
      else if (state=="DOWN") color=cr;
      else if (state=="UNKNOWN") color=cy;
      printf "%s%-16s %-8s%s %s\n", color, iface, state, cn, rest
    }'
else
  echo "ip nicht verfügbar (Tipp: sudo apt install iproute2)"
fi
echo

section "Open Ports"
if command -v ss >/dev/null 2>&1; then
  ss -tulpn || true
else
  echo "ss nicht verfügbar (Tipp: sudo apt install iproute2)"
fi
echo

section "Services"
# B) Key-Liste + Running-Liste (übersichtlich, server-optimiert)
if command -v systemctl >/dev/null 2>&1; then
  echo "${c_cyan}Key Services:${c_reset}"
  KEY_SERVICES=(ssh sshd nginx docker node fail2ban ufw)

  any_key=false
  for svc in "${KEY_SERVICES[@]}"; do
    if systemctl list-unit-files 2>/dev/null | grep -q "^${svc}\.service"; then
      any_key=true
      state="$(systemctl is-active "$svc" 2>/dev/null || true)"
      if [[ "$state" == "active" ]]; then
        printf "✓ %-14s %b\n" "$svc" "${c_green}active${c_reset}"
      else
        printf "✗ %-14s %b\n" "$svc" "${c_yellow}${state:-inactive}${c_reset}"
      fi
    else
      printf "– %-14s %b\n" "$svc" "${c_dim}not installed${c_reset}"
    fi
  done

  echo
  echo "${c_cyan}Running Services (top 15):${c_reset}"
  running_services="$(systemctl list-units --type=service --state=running --no-legend --no-pager 2>/dev/null || true)"

  if [[ -z "${running_services// /}" ]]; then
    echo "– Aktuell sind keine Services aktiv"
  else
    echo "$running_services" | head -n 15 | awk '
      {
        unit=$1; $1=""; sub(/^ +/,""); desc=$0;
        printf "✓ %-35s %s\n", unit, desc
      }'
    echo "${c_dim}… mehr: systemctl list-units --type=service --state=running${c_reset}"
  fi
else
  echo "– systemctl nicht verfügbar (kein systemd)."
fi
echo

section "Maintenance Tools"
print_tool() {
  local tool="$1"
  local pkg="$2"

  if command -v "$tool" >/dev/null 2>&1; then
    printf "✓ %-14s (installiert)\n" "$tool"
  else
    printf "✗ %-14s (nicht installiert) → installiere mit: sudo apt install %s\n" "$tool" "$pkg"
  fi
}

echo "[System]"
print_tool btop btop
print_tool htop htop
print_tool uptime coreutils
print_tool free procps
print_tool df coreutils
print_tool sensors lm-sensors
print_tool journalctl systemd

echo
echo "[Disk]"
print_tool ncdu ncdu
print_tool lsblk util-linux
print_tool mount util-linux
print_tool iostat sysstat
print_tool smartctl smartmontools

echo
echo "[Network]"
print_tool ip iproute2
print_tool ss iproute2
print_tool iftop iftop
print_tool lsof lsof
print_tool ping iputils-ping
print_tool traceroute traceroute

echo
echo "[Security]"
print_tool ufw ufw
print_tool fail2ban-client fail2ban
echo
